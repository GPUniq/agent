# GPUniq Agent - ООП Архитектура

Этот проект представляет собой агента для платформы GPUniq, переписанный с использованием объектно-ориентированного подхода.

## Архитектура

### Основные классы

#### 1. `HardwareAnalyzer` (`hardware_analyzer.py`)
Класс для анализа характеристик компьютера:

**Основные методы:**
- `get_cpu_info()` - информация о процессорах
- `get_gpu_info()` - информация о видеокартах
- `get_disk_info()` - информация о дисках
- `get_network_info()` - информация о сетевых интерфейсах
- `get_ram_info()` - информация о памяти
- `get_system_info()` - общая системная информация
- `get_ip_address()` - получение IP адреса
- `get_location_from_ip()` - определение локации по IP

**Особенности:**
- Кэширование результатов для оптимизации
- Поддержка Linux, Windows, macOS
- Детальный анализ GPU (NVIDIA, AMD, Intel)
- Автоматическое определение типа RAM

#### 2. `APIClient` (`api_client.py`)
Класс для взаимодействия с API gpuniq.ru:

**Основные методы:**
- `confirm_agent()` - подтверждение агента
- `send_init_data()` - отправка данных инициализации
- `poll_for_tasks()` - опрос задач от сервера
- `send_task_status()` - отправка статуса задач
- `send_heartbeat()` - отправка heartbeat
- `start_polling_thread()` - запуск потока опроса

**Особенности:**
- Автоматическая обработка ошибок
- Retry логика с экспоненциальной задержкой
- Потокобезопасность
- Управление сессией requests

#### 3. `Agent` (`agent_main.py`)
Основной класс агента, координирующий работу всех компонентов:

**Основные методы:**
- `initialize()` - инициализация агента
- `collect_system_data()` - сбор данных о системе
- `collect_monitoring_data()` - сбор данных мониторинга
- `process_task()` - обработка задач
- `run()` - основной цикл работы

**Особенности:**
- Интеграция всех компонентов
- Управление жизненным циклом
- Graceful shutdown
- Сохранение/загрузка agent_id

#### 4. `ContainerManager` (`manager.py`)
Класс для управления Docker контейнерами:

**Основные методы:**
- `start()` - запуск контейнера
- `stop()` - остановка контейнера
- `_exists()` - проверка существования
- `_running()` - проверка статуса

**Особенности:**
- Автоматическое управление портами
- Поддержка GPU
- SSH и Jupyter настройка
- Управление томами

## Использование

### Запуск агента

```bash
python agent_main.py <secret_key>
```

### Пример использования классов

```python
from hardware_analyzer import HardwareAnalyzer
from api_client import APIClient
from agent_main import Agent

# Анализ железа
analyzer = HardwareAnalyzer()
system_info = analyzer.get_system_info()
print(system_info)

# Работа с API
api_client = APIClient(secret_key="your_secret_key")
agent_id = api_client.confirm_agent(system_info)

# Полный агент
agent = Agent(secret_key="your_secret_key")
agent.run()
```

## Преимущества ООП архитектуры

### 1. Модульность
- Каждый класс отвечает за свою область
- Легко тестировать отдельные компоненты
- Простое добавление новых функций

### 2. Переиспользование
- Классы можно использовать независимо
- Легко создавать разные конфигурации
- Возможность наследования и расширения

### 3. Инкапсуляция
- Внутренняя логика скрыта от внешнего кода
- Четкие интерфейсы между компонентами
- Защита от случайного изменения состояния

### 4. Управление состоянием
- Кэширование в HardwareAnalyzer
- Сохранение agent_id
- Управление сессией API

### 5. Расширяемость
- Легко добавить новые типы анализа
- Простое добавление новых API методов
- Возможность создания разных типов агентов

## Структура файлов

```
agent/
├── hardware_analyzer.py    # Анализ характеристик компьютера
├── api_client.py          # Взаимодействие с API
├── manager.py             # Управление Docker контейнерами
├── agent_main.py          # Основной класс агента
├── installator.py         # Старый функциональный код (для справки)
└── README_OO.md           # Этот файл
```

## Миграция с функционального подхода

### Что изменилось:
1. **Функции → Классы**: Все функции анализа железа теперь методы класса `HardwareAnalyzer`
2. **Глобальные переменные → Атрибуты**: Состояние хранится в атрибутах классов
3. **Параметры → Конструкторы**: Настройки передаются через конструкторы
4. **Callback функции**: API использует callback для обработки задач

### Что осталось:
1. **Бизнес-логика**: Вся логика анализа железа сохранена
2. **API взаимодействие**: Все методы API сохранены
3. **Docker управление**: Используется существующий `manager.py`

## Дальнейшее развитие

### Возможные улучшения:
1. **Конфигурация**: Добавить класс для управления настройками
2. **Логирование**: Создать класс для централизованного логирования
3. **Мониторинг**: Расширить класс для детального мониторинга
4. **Плагины**: Система плагинов для расширения функциональности
5. **Тесты**: Unit тесты для каждого класса

### Пример расширения:

```python
class ConfigManager:
    def __init__(self, config_file: str):
        self.config = self.load_config(config_file)
    
    def get_setting(self, key: str):
        return self.config.get(key)

class LogManager:
    def __init__(self, log_file: str):
        self.log_file = log_file
    
    def log(self, level: str, message: str):
        # Логирование с ротацией файлов
        pass

class ExtendedAgent(Agent):
    def __init__(self, secret_key: str, config_file: str):
        super().__init__(secret_key)
        self.config = ConfigManager(config_file)
        self.logger = LogManager(self.config.get_setting('log_file'))
```

Эта архитектура обеспечивает чистый, поддерживаемый и расширяемый код, который легко тестировать и развивать.
